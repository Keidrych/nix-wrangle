{ stdenv, lib, git, callPackage, makeWrapper, fetchFromGitHub, haskellPackages, enableSplice ? true, self ? ../. }:
# ./wrangle.nix is the vanilla cabal2nix output, so we wrap it here:
let
	splice =
		let ret = if enableSplice then {
			flag = "+splice";
			filterDeps = x: true;
		} else {
			flag = "-splice";
			filterDeps = drv: if drv == null then false else
				builtins.trace "filtercheck: ${if drv == null then "NULL" else drv.pname}" (drv.pname != "hnix"); # could exclude more, but hnix is the big one
		}; in
		builtins.trace "splice flag: ${ret.flag}" ret;

	# This is a bit silly. Since `haskellPackages.mkDerivation` embeds so much that's hard to override,
	# we fake `mkDerivation` to capture the raw arguments (generated by `cabal2nix`).
	# Then we can filter them, _then_ pass them on to the real mkDerivation:
	wrapped = haskellPackages.callPackage ./wrangle.nix { mkDerivation = args:
		# callPackage merges in some extra attrs to whatever we return, so nest this in `args`
		{ inherit args; };
	};
in

haskellPackages.mkDerivation (let o = wrapped.args; in o // rec {
	src = self;
	executableHaskellDepends = lib.filter splice.filterDeps (o.executableHaskellDepends);
	buildDepends = (o.buildDepends or []) ++ [ makeWrapper ];
	configureFlags = (o.configureFlags or []) ++ ["--flags=${splice.flag}"];
	postInstall = ''
		mkdir -p "$out/share"
		cp -r "$src/nix" "$out/share/nix"
		wrapProgram $out/bin/nix-wrangle \
			--prefix PATH : ${git}/bin \
			--set NIX_WRANGLE_DATA "$out/share"
		$out/bin/nix-wrangle installcheck
	'';
	passthru = {
		api = args: callPackage (../nix + "/api.nix") args;
	};
})
